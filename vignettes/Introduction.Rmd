---
title: "Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to deflist}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
---
title: "Introduction to the deflist Package"
author: "Bradley Buchsbaum"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to the deflist Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The `deflist` package provides a read-only list-like object that retrieves elements with a function call. This is particularly useful for handling large datasets where elements are computed on-demand and not stored in memory.

In this vignette, we will provide an overview of the main features of the `deflist` package and demonstrate its usage with examples.

## Creating a deferred list

To create a deferred list, use the `deflist` function. The key input is a function that defines how to access elements in the list. The deferred list can also be configured to memoise element access and cache the results for faster retrieval.

Let's create a simple deferred list for square numbers:

```{r}
library(deflist)

square_fun <- function(i) i^2
square_deflist <- deflist(square_fun, len = 5)
square_deflist

```

## Accessing elements

Elements in a deferred list can be accessed using standard list indexing, either by position or by name (if names are provided):

```{r}
# Access by index
square_deflist[[1]]
square_deflist[[2]]

# Access multiple elements
square_deflist[c(1, 3, 5)]
```

## Memoisation
Deferred lists can be configured to use memoisation, which caches the results of function calls to speed up repeated access to the same elements. To enable memoisation, set the memoise argument to TRUE when creating the deferred list. You can also specify a cache type ("memory" or "file") and a cache directory for file-based caching.

Here's an example with memoisation enabled:

```{r}
memoised_square_fun <- deflist(square_fun, len = 5, memoise = TRUE, cache = "memory")
memoised_square_fun

# Access an element multiple times
system.time({ for (i in 1:1000) memoised_square_fun[[1]] })
```

## Converting to a list

A deferred list can be converted to a standard R list using the as.list method:

```{r}

square_list <- as.list(square_deflist)
square_list

```

## Read-only protection

Deferred lists are read-only, meaning that you cannot modify their elements. Attempting to do so will result in an error:

```{r}
try(square_deflist[[1]] <- 0)
```

## Conclusion

The deflist package provides a flexible  way to work with large datasets that require on-demand computation. It can be easily integrated into existing R workflows, making it a valuable tool for a wide range of applications.
